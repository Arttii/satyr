# coding: utf-8

from __future__ import absolute_import, division, print_function

#import logging

from mesos.interface import mesos_pb2
from mesos.interface import Scheduler, SchedulerDriver
from mesos.interface import Executor, ExecutorDriver
from mesos.interface.mesos_pb2 import FrameworkInfo


from .primitives import Offer
from .utils import catch
from . import log as logging

__all__ = ('SchedulerProxy',
           'ExecutorProxy'
           'SchedulerDriverProxy',
           'ExecutorDriverProxy')


# TODO add logging to all methods
class SchedulerProxy(Scheduler):

    def __init__(self, scheduler):
        self.scheduler = scheduler

    def registered(self, driver, frameworkId, masterInfo):
        """Invoked when the scheduler successfully registers with a master.

        It is called with the frameworkId, a unique ID generated by the master,
        and the masterInfo which is information about the master itself.
        """
        driver = SchedulerDriverProxy(driver)
        return self.scheduler.on_registered(driver, frameworkId, masterInfo)

    def reregistered(self, driver, masterInfo):
        """Invoked when the scheduler re-registers with a newly elected master.

        This is only called when the scheduler has previously been registered.
        masterInfo contains information about the newly elected master.
        """
        logging.info("Re-registered with master", extra=dict(
            master_pid=masterInfo.pid, master_hostname=masterInfo.hostname,
            master_id=masterInfo.id, master_ip=masterInfo.ip,
            master_port=masterInfo.port))
        driver = SchedulerDriverProxy(driver)
        return self.scheduler.on_reregistered(driver, masterInfo)

    def disconnected(self, driver):
        """Invoked when the scheduler becomes disconnected from the master.

        (e.g. the master fails and another is taking over)
        """
        driver = SchedulerDriverProxy(driver)
        return self.scheduler.on_disconnected(driver)

    def resourceOffers(self, driver, offers):
        """Invoked when resources have been offered to this framework.

        A single offer will only contain resources from a single slave.
        Resources associated with an offer will not be re-offered to _this_
        framework until either (a) this framework has rejected those resources
        (see SchedulerDriver.launchTasks) or (b) those resources have been
        rescinded (see Scheduler.offerRescinded).

        Note that resources may be concurrently offered to more than one
        framework at a time (depending on the allocator being used).  In that
        case, the first framework to launch tasks using those resources will be
        able to use them while the other frameworks will have those resources
        rescinded (or if a framework has already launched tasks with those
        resources then those tasks will fail with a TASK_LOST status and a
        message saying as much).
        """
        logging.debug("Got resource offers", extra=dict(num_offers=len(offers)))
        driver = SchedulerDriverProxy(driver)
        offers = map(Offer.decode, offers)
        return self.scheduler.on_offers(driver, offers)

    def offerRescinded(self, driver, offerId):
        """Invoked when an offer is no longer valid.

        (e.g., the slave was lost or another framework used resources in the
        offer)

        If for whatever reason an offer is never rescinded (e.g., dropped
        message, failing over framework, etc.), a framework that attempts to
        launch tasks using an invalid offer will receive TASK_LOST status
        updates for those tasks (see Scheduler.resourceOffers).
        """
        logging.debug('Offer rescinded', extra=dict(offer_id=offerId.value))
        driver = SchedulerDriverProxy(driver)
        return self.scheduler.on_rescinded(driver, offerId)

    def statusUpdate(self, driver, status):
        """Invoked when the status of a task has changed.

        (e.g., a slave is lost and so the task is lost, a task finishes and an
        executor sends a status update saying so, etc.)

        If implicit acknowledgements are being used, then returning from this
        callback _acknowledges_ receipt of this status update!

        If for  whatever reason the scheduler aborts during this callback (or
        the process exits) another status update will be delivered (note,
        however, that this is currently not true if the slave sending the status
        update is lost/fails during that time).

        If explicit acknowledgements are in use, the scheduler must acknowledge
        this status on the driver.
        """
        #task = self.tasks(update.status_id.value)
        driver = SchedulerDriverProxy(driver)
        return self.scheduler.on_update(driver, status)

    def frameworkMessage(self, driver, executorId, slaveId, message):
        """Invoked when an executor sends a message.

        These messages are best effort; do not expect a framework message to be
        retransmitted in any reliable fashion.
        """
        # TODO log
        driver = SchedulerDriverProxy(driver)
        return self.scheduler.on_message(self, driver, executorId, slaveId,
                                         message)

    def slaveLost(self, driver, slaveId):
        """Invoked when a slave has been determined unreachable.

        (e.g., machine failure, network partition.)

        Most frameworks will need to reschedule any tasks launched on this slave
        on a new slave.
        """
        # TODO log
        driver = SchedulerDriverProxy(driver)
        return self.scheduler.on_slave_lost(driver, slaveId)

    def executorLost(self, driver, executorId, slaveId, status):
        """Invoked when an executor has exited/terminated.

        Note that any tasks running will have TASK_LOST status updates
        automatically generated.

        NOTE: This callback is not reliably delivered.
        """
        # TODO log
        driver = SchedulerDriverProxy(driver)
        return self.scheduler.on_executor_lost(driver, executorId, slaveId, status)

    def error(self, driver, message):
        """Invoked when there is an unrecoverable error in the scheduler or
           scheduler driver.

        The driver will be aborted BEFORE invoking this callback.
        """
        # TODO log
        print("Error from Mesos: %s " % message, file=sys.stderr)
        driver = SchedulerDriverProxy(driver)
        return self.scheduler.on_error(driver, message)


class ExecutorProxy(Executor):
    """Base class for Mesos executors.

    Users' executors should extend this class to get default implementations of
    methods they don't override.
    """

    def __init__(self, executor):
        self.executor = executor

    def registered(self, driver, executorInfo, frameworkInfo, slaveInfo):
        """Invoked once the executor driver has been able to successfully connect
           with Mesos.

        In particular, a scheduler can pass some data to its executors through
        the FrameworkInfo.ExecutorInfo's data field.
        """
        # TODO logging
        driver = ExecutorDriverProxy(driver)
        return self.executor.on_registered(driver, executorInfo, frameworkInfo,
                                           slaveInfo)

    def reregistered(self, driver, slaveInfo):
        """Invoked when the executor re-registers with a restarted slave."""
        # TODO logging
        driver = ExecutorDriverProxy(driver)
        return self.executor.on_reregistered(driver, slaveInfo)

    def disconnected(self, driver):
        """Invoked when the executor becomes "disconnected" from the slave

        (e.g., the slave is being restarted due to an upgrade)
        """
        # TODO logging
        driver = ExecutorDriverProxy(driver)
        return self.executor.on_disconnected(driver)

    def launchTask(self, driver, task):
        """Invoked when a task has been launched on this executor (initiated via
           Scheduler.launchTasks).

        Note that this task can be realized with a thread, a process, or some
        simple computation, however, no other callbacks will be invoked on this
        executor until this callback has returned.
        """
        # TODO logging
        driver = ExecutorDriverProxy(driver)
        return self.executor.on_launch(driver, task)

    def killTask(self, driver, taskId):
        """Invoked when a task running within this executor has been killed (via
           SchedulerDriver.killTask).

        Note that no status update will be sent on behalf of the executor, the
        executor is responsible for creating a new TaskStatus (i.e., with
        TASK_KILLED) and invoking ExecutorDriver's sendStatusUpdate.
        """
        # TODO logging
        driver = ExecutorDriverProxy(driver)
        return self.executor.on_kill(driver, task_id)

    def frameworkMessage(self, driver, message):
        """Invoked when a framework message has arrived for this executor.

        These messages are best effort; do not expect a framework message to be
        retransmitted in any reliable fashion.
        """
        # TODO logging
        driver = ExecutorDriverProxy(driver)
        return self.executor.on_message(driver, message)

    def shutdown(self, driver):
        """Invoked when the executor should terminate all of its currently
           running tasks.

        Note that after Mesos has determined that an executor has terminated any
        tasks that the executor did not send terminal status updates for (e.g.,
        TASK_KILLED, TASK_FINISHED, TASK_FAILED, etc) a TASK_LOST status update
        will be created.
        """
        # TODO logging
        driver = ExecutorDriverProxy(driver)
        return self.executor.on_shutdown(driver)

    def error(self, driver, message):
        """Invoked when a fatal error has occurred with the executor and/or
           executor driver.

        The driver will be aborted BEFORE invoking this callback.
        """
        # TODO logging
        print("Error from Mesos: %s" % message, file=sys.stderr)
        driver = ExecutorDriverProxy(driver)
        return self.executor.on_error(driver, message)


class SchedulerDriverProxy(SchedulerDriver):

    def __init__(self, driver):
        self.driver = driver

    def request(self, requests):
        """Requests resources from Mesos.

        (see mesos.proto for a description of Request and how, for example, to
        request resources from specific slaves.)

        Any resources available are offered to the framework via
        Scheduler.resourceOffers callback, asynchronously.
        """
        request_infos = [req.encode() for req in requests]
        return self.driver.requestResources(request_infos)

    def launch(self, offer, tasks, filters=None):
        """Launches the given set of tasks.

        Any resources remaining (i.e., not used by the tasks or their executors)
        will be considered declined.
        The specified filters are applied on all unused resources (see
        mesos.proto for a description of Filters). Available resources are
        aggregated when multiple offers are provided. Note that all offers must
        belong to the same slave. Invoking this function with an empty
        collection of tasks declines the offers in entirety (see
        Scheduler.declineOffer).

        Note that passing a single offer is also supported.
        """
        task_infos = [task.encode(offer) for task in tasks]
        self.driver.launchTasks(offer.id, task_infos, filters=filters)  # filters?

    def kill(self, task):
        """Kills the specified task.

        Note that attempting to kill a task is currently not reliable.
        If, for example, a scheduler fails over while it was attempting to kill
        a task it will need to retry in the future.
        Likewise, if unregistered / disconnected, the request will be dropped
        (these semantics may be changed in the future).
        """
        return self.driver.killTask(task.id)

    def reconcile(self, tasks):
        """Allows the framework to query the status for non-terminal tasks.

        This causes the master to send back the latest task status for each task
        in 'statuses', if possible. Tasks that are no longer known will result
        in a TASK_LOST update. If statuses is empty, then the master will send
        the latest status for each task currently known.
        """
        task_infos = [task.encode() for task in tasks]
        return self.driver.reconcileTasks(task_infos)

    def decline(self, offer, filters=None):
        """Declines an offer in its entirety and applies the specified
           filters on the resources (see mesos.proto for a description of
           Filters).

        Note that this can be done at any time, it is not necessary to do this
        within the Scheduler::resourceOffers callback.
        """
        return self.driver.declineOffer(offer.id)  #TODO filters

    def accept(self, offer_ids, operations, filters=None):
        """Accepts the given offers and performs a sequence of operations
           on those accepted offers.

        See Offer.Operation in mesos.proto for the set of available operations.
        Available resources are aggregated when multiple offers are provided.

        Note that all offers must belong to the same slave. Any unused resources
        will be considered declined. The specified filters are applied on all
        unused resources (see mesos.proto for a description of Filters).
        """
        return self.driver.acceptOffers(self, offer_ids, operations, filters)

    def revive(self):
        """Removes all filters previously set by the framework (via
           launchTasks()).

        This enables the framework to receive offers from those filtered slaves.
        """
        return self.driver.reviveOffers()

    def suppress(self):
        """Inform Mesos master to stop sending offers to the framework.

        The scheduler should call reviveOffers() to resume getting offers.
        """
        return self.driver.suppressOffers()

    def acknowledge(self, status):
        """Acknowledges the status update.

        This should only be called once the status update is processed durably
        by the scheduler.

        Not that explicit acknowledgements must be requested via the constructor
        argument, otherwise a call to this method will cause the driver to
        crash.
        """
        return self.driver.acknowledgeStatusUpdate(status)

    def message(self, executor, slave, message):
        """Sends a message from the framework to one of its executors.

        These messages are best effort; do not expect a framework message to be
        retransmitted in any reliable fashion.
        """
        return self.driver.sendFrameworkMessage(executor, slave, message)


class ExecutorDriverProxy(ExecutorDriver):

    def __init__(self, driver):
        self.driver = driver

    def start(self):
        """Starts the executor driver.

        This needs to be called before any other driver calls are made.
        """
        return self.driver.start()

    def stop(self):
        """Stops the executor driver."""
        return self.driver.stop()

    def abort(self):
        """Aborts the driver so that no more callbacks can be made to the
           executor.

        The semantics of abort and stop have deliberately been separated so that
        code can detect an aborted driver (i.e., via the return status of
        ExecutorDriver.join), and instantiate and start another driver if
        desired (from within the same process, although this functionality is
        currently not supported for executors).
        """
        return self.driver.abort()

    def join(self):
        """Waits for the driver to be stopped or aborted, possibly blocking the
           current thread indefinitely.

        The return status of this function can be used to determine if the
        driver was aborted (see mesos.proto for a description of Status).
        """
        return self.driver.join()

    def run(self):
        """Starts and immediately joins (i.e., blocks on) the driver."""
        return self.driver.run()

    def update(self, status):
        """Sends a status update to the framework scheduler.

        Retrying as necessary until an acknowledgement has been received or the
        executor is terminated (in which case, a TASK_LOST status update will be
        sent).
        See Scheduler.statusUpdate for more information about status update
        acknowledgements.
        """
        return self.driver.sendStatusUpdate(status)

    def message(self, data):
        """Sends a message to the framework scheduler.

        These messages are best effort; do not expect a framework message to be
        retransmitted in any reliable fashion.
        """
        return self.driver.sendFrameworkMessage(data)
