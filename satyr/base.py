from __future__ import absolute_import, division, print_function

#import logging

from mesos.interface import Scheduler as MesosScheduler
from mesos.interface import Executor as MesosExecutor

from .utils import catch
from .core import Offer
from . import log as logging

# project name MEDUSA

class Scheduler(MesosScheduler):

    #@log
    def registered(self, driver, frameworkId, masterInfo):
        """Invoked when the scheduler successfully registers with a master.

        It is called with the frameworkId, a unique ID generated by the master,
        and the masterInfo which is information about the master itself.
        """
        logging.info("Registered with master", extra=dict(
            framework_id=frameworkId.value, master_pid=masterInfo.pid,
            master_hostname=masterInfo.hostname, master_id=masterInfo.id,
            master_ip=masterInfo.ip, master_port=masterInfo.port))
        #self.on_registered(driver, frameworkId, masterInfo)

    def reregistered(self, driver, masterInfo):
        """Invoked when the scheduler re-registers with a newly elected master.

        This is only called when the scheduler has previously been registered.
        masterInfo contains information about the newly elected master.
        """
        logging.info("Re-registered with master", extra=dict(
            master_pid=masterInfo.pid, master_hostname=masterInfo.hostname,
            master_id=masterInfo.id, master_ip=masterInfo.ip,
            master_port=masterInfo.port))

    def disconnected(self, driver):
        """Invoked when the scheduler becomes disconnected from the master.

        (e.g. the master fails and another is taking over)
        """

    def match(self, offers):
        return {} # mappings

    def resourceOffers(self, driver, offers):
        """Invoked when resources have been offered to this framework.

        A single offer will only contain resources from a single slave.
        Resources associated with an offer will not be re-offered to _this_
        framework until either (a) this framework has rejected those resources
        (see SchedulerDriver.launchTasks) or (b) those resources have been
        rescinded (see Scheduler.offerRescinded).

        Note that resources may be concurrently offered to more than one
        framework at a time (depending on the allocator being used).  In that
        case, the first framework to launch tasks using those resources will be
        able to use them while the other frameworks will have those resources
        rescinded (or if a framework has already launched tasks with those
        resources then those tasks will fail with a TASK_LOST status and a
        message saying as much).
        """
        logging.debug("Got resource offers", extra=dict(num_offers=len(offers)))

        offers = map(Offer.decode, offers)

        to_launch = self.match(offers)
        to_decline = [o for o in offers if o not in to_launch]

        for offer, tasks in to_launch.items():
            task_infos = [task.encode(offer) for task in tasks]
            driver.launchTasks(offer.id, task_infos, filters=None)  # filters?

        for offer in to_decline:  # decline remaining unused offers
            driver.declineOffer(offer.id)


    def offerRescinded(self, driver, offerId):
        """Invoked when an offer is no longer valid.

        (e.g., the slave was lost or another framework used resources in the
        offer)

        If for whatever reason an offer is never rescinded (e.g., dropped
        message, failing over framework, etc.), a framework that attempts to
        launch tasks using an invalid offer will receive TASK_LOST status
        updates for those tasks (see Scheduler.resourceOffers).
        """
        logging.debug('Offer rescinded', extra=dict(offer_id=offerId.value))

    def statusUpdate(self, driver, status):
        """Invoked when the status of a task has changed.

        (e.g., a slave is lost and so the task is lost, a task finishes and an
        executor sends a status update saying so, etc.)

        If implicit acknowledgements are being used, then returning from this
        callback _acknowledges_ receipt of this status update!

        If for  whatever reason the scheduler aborts during this callback (or
        the process exits) another status update will be delivered (note,
        however, that this is currently not true if the slave sending the status
        update is lost/fails during that time).

        If explicit acknowledgements are in use, the scheduler must acknowledge
        this status on the driver.
        """
        task = self.tasks(update.status_id.value)

    def frameworkMessage(self, driver, executorId, slaveId, message):
        """Invoked when an executor sends a message.

        These messages are best effort; do not expect a framework message to be
        retransmitted in any reliable fashion.
        """

    def slaveLost(self, driver, slaveId):
        """Invoked when a slave has been determined unreachable.

        (e.g., machine failure, network partition.)

        Most frameworks will need to reschedule any tasks launched on this slave
        on a new slave.
        """

    def executorLost(self, driver, executorId, slaveId, status):
        """Invoked when an executor has exited/terminated.

        Note that any tasks running will have TASK_LOST status updates
        automatically generated.

        NOTE: This callback is not reliably delivered.
        """

    def error(self, driver, message):
        """Invoked when there is an unrecoverable error in the scheduler or
           scheduler driver.

        The driver will be aborted BEFORE invoking this callback.
        """
        print("Error from Mesos: %s " % message, file=sys.stderr)



# class SatyrScheduler(Scheduler):
#     task_status_modifiers = {
#         mesos_pb2.TASK_RUNNING: [('running', 1)],
#         mesos_pb2.TASK_FINISHED: [('running', -1), ('successful', 1)],
#         mesos_pb2.TASK_FAILED: [('running', -1), ('failed', 1)],
#         mesos_pb2.TASK_LOST: [('running', -1), ('failed', 1)],
#         mesos_pb2.TASK_KILLED: [('running', -1), ('failed', 1)],
#         mesos_pb2.TASK_STAGING: [],
#         mesos_pb2.TASK_STARTING: []
#     }

#     task_stats = {'running': 0, 'successful': 0, 'failed': 0, 'created': 0}
#     driver_states = {'is_starting': True,
#                      'force_shutdown': False,
#                      'is_running': True}

#     def __init__(self, config, framework_message):
#         print('Starting framework [%s]' % config['name'])
#         self.config = config
#         self.framework_message = framework_message
#         self.name = config['name']
#         self.task_queue = Queue()
#         self.satyr = None

#     def frameworkMessage(self, driver, executorId, slaveId, data):
#         self.framework_message(self, driver, executorId, slaveId, data)

#     def statusUpdate(self, driver, taskStatus):
#         status = taskStatus.state
#         print('Recieved a status update [%s]' % status)
#         if status not in self.task_status_modifiers:
#             print('Unknown state code [%s]' % status)

#         for name, value in self.task_status_modifiers[status]:
#             self.task_stats[name] += value

#         self.driver_states['is_starting'] = False

#         # TODO do something w/ this extreme code smell
#         if self.satyr:
#             self.satyr.update_task_status(taskStatus)

#     def resourceOffers(self, driver, offers):
#         print('Recieved %d resource offer(s)' % len(offers))

#         _filters = filters(self.config)

#         def handle_offers(driver, offers):
#             self.shutdown_if_done(driver)
#             for offer in offers:
#                 if not self.should_be_running():
#                     print('Declining offer [%s]' % offer.id)
#                     driver.declineOffer(offer.id, _filters)
#                     continue

#                 tasks = [create_task(offer, task) for task in create_task_list(
#                     get_resources_from_offer(offer), [])]

#                 print('We\'re starting %d new task(s)' % len(tasks))
#                 driver.launchTasks(offer.id, tasks) if tasks else driver.declineOffer(
#                     offer.id, filters)

#         def get_resources_from_offer(offer):
#             return {res.name: res.scalar.value for res in offer.resources}

#         def create_task_list(resources, tasks):
#             if not len(self.task_queue):
#                 return tasks

#             task = self.task_queue.popleft()
#             task_resources = create_task_resources(task)
#             fits = task_fits_into_remaining_resources(
#                 resources, task_resources)

#             if fits and len(tasks) < self.config['max_tasks']:
#                 tasks.append(task)
#                 return create_task_list(
#                     create_new_task_resources(resources, task_resources), tasks)

#             self.task_queue.appendleft(task)

#             return tasks

#         def task_fits_into_remaining_resources(resources, task_resources):
#             """Checks if the following task fits into the remaining
#             resources of the offer. Currently only this stupid
#             implementation is available. It checks the tasks according
#             to the list and only verifies if the current task fits.
#             A smarter, resource optimized method could be easely
#             introduced."""
#             def fits(name, val):
#                 return val - task_resources.get(name, 0) > 0

#             return all([fits(name, val) for name, val in resources.items() if name in task_resources])

#         def create_new_task_resources(resources, task_resources):
#             def calc(name, val):
#                 return val - task_resources.get(name, 0)

#             return {name: calc(name, val) for name, val in resources.items() if name in task_resources}

#         def create_task(offer, data):
#             self.task_stats['created'] += 1

#             executor = executor_info(self.config, data)
#             task = task_info(data, self, executor, offer)
#             add_resources_to_task(task, data)

#             return task

#         def add_resources_to_task(task, data):
#             for name, val in create_task_resources(data).items():
#                 res = task.resources.add()
#                 res.name = name
#                 res.type = mesos_pb2.Value.SCALAR
#                 res.scalar.value = val

#         def create_task_resources(data):
#             if isinstance(data, dict) and data.get('resources'):
#                 return data['resources']

#             return self.config['resources']

#         t = Thread(target=handle_offers, args=(driver, offers))
#         t.start()

#     def add_job(self, message):
#         self.task_queue.append(message)

#     def should_be_running(self):
#         return self.task_queue or self.task_stats['running'] >= self.config['max_tasks']

#     def shutdown_if_done(self, driver):
#         if self.driver_states['force_shutdown'] or not any((
#                 self.config['permanent'],
#                 self.driver_states['is_starting'],
#                 self.task_stats['running'],
#                 len(self.task_queue))):
#             print('We are finished.')
#             self.shutdown(driver)

#     def shutdown(self, driver):
#         driver.stop()
#         self.driver_states['is_running'] = False

class Executor(MesosExecutor):
    """Base class for Mesos executors.

    Users' executors should extend this class to get default implementations of
    methods they don't override.
    """

    def registered(self, driver, executorInfo, frameworkInfo, slaveInfo):
        """Invoked once the executor driver has been able to successfully connect
           with Mesos.

        In particular, a scheduler can pass some data to its executors through
        the FrameworkInfo.ExecutorInfo's data field.
        """

    def reregistered(self, driver, slaveInfo):
        """Invoked when the executor re-registers with a restarted slave."""

    def disconnected(self, driver):
        """Invoked when the executor becomes "disconnected" from the slave

        (e.g., the slave is being restarted due to an upgrade)
        """

    def launchTask(self, driver, task):
        """Invoked when a task has been launched on this executor (initiated via
           Scheduler.launchTasks).

        Note that this task can be realized with a thread, a process, or some
        simple computation, however, no other callbacks will be invoked on this
        executor until this callback has returned.
        """

    def killTask(self, driver, taskId):
        """Invoked when a task running within this executor has been killed (via
           SchedulerDriver.killTask).

        Note that no status update will be sent on behalf of the executor, the
        executor is responsible for creating a new TaskStatus (i.e., with
        TASK_KILLED) and invoking ExecutorDriver's sendStatusUpdate.
        """

    def frameworkMessage(self, driver, message):
        """Invoked when a framework message has arrived for this executor.

        These messages are best effort; do not expect a framework message to be
        retransmitted in any reliable fashion.
        """

    def shutdown(self, driver):
        """Invoked when the executor should terminate all of its currently
           running tasks.

        Note that after Mesos has determined that an executor has terminated any
        tasks that the executor did not send terminal status updates for (e.g.,
        TASK_KILLED, TASK_FINISHED, TASK_FAILED, etc) a TASK_LOST status update
        will be created.
        """

    def error(self, driver, message):
        """Invoked when a fatal error has occurred with the executor and/or
           executor driver.

        The driver will be aborted BEFORE invoking this callback.
        """
        print("Error from Mesos: %s" % message, file=sys.stderr)



# class SatyrExecutor(Executor):
#     ALLOWED_HANDLERS = ['runTask']

#     def __init__(self, run_task):
#         self.run_task = run_task

#     def launchTask(self, driver, task):
#         driver.sendStatusUpdate(self.create_status_update(
#             task, mesos_pb2.TASK_STARTING))
#         thread = threading.Thread(target=self.run_task, args=(self, driver, task))
#         thread.start()

#     def create_status_update(self, task, state):
#         update = mesos_pb2.TaskStatus()
#         update.task_id.value = task.task_id.value
#         update.state = state
#         return update

#     def send_status_update(self, driver, task, state):
#         driver.sendStatusUpdate(self.create_status_update(task, state))

#     def send_framework_message(self, driver, message):
#         driver.sendFrameworkMessage(message)

#     def run(self):
#         driver.run(MesosExecutorDriver(self))
